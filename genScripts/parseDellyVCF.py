#!/bin/python
import argparse
import sys
import glob
import logging
from datetime import datetime
import os

def main():
    # Setup logging
    LOG_FILENAME="logging-parseDellyVCF-" + datetime.now().strftime("%Y%m%d-%H%M%S") + ".log"
    logging.basicConfig(filename=LOG_FILENAME,
                        level = logging.DEBUG,
                        format = '%(asctime)s: %(message)s')
    logging.info("Starting parsing of Delly VCFs...")
    # Setup arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--folders', nargs='+', help='List of folders containing a VCF generated by Delly',
                        required=True)
    args = parser.parse_args()
    for folder in args.folders:
        parseDellyTx(folder)
    logging.info("DONE.")

class DellyVCFline(object):
    """
    Contains the lines of a Delly VCF.
    """
    def __init__(self, line):
        self.line = line
        self.info = None
        self.format = None
        self.chr1 = None
        self.chr2 = None
        self.pos1 = None
        self.pos2 = None
        self.precision = None
        self.filter = None
        self.connection = None
        self.PEsupport = None
        self.MQ = None  #for paired ends
        self.varDepth = None
        self.refPairs = None
        self.varPairs = None
        self.refJxReads = None
        self.varJxReads = None

    def loadVar(self):
        toks = self.line.strip('\n').split('\t')
        self.chr1 = toks[0]
        self.pos1 = toks[1]
        self.filter=toks[6]
        self.info=toks[7].split(';')
        self.precision=self.info[0]
        self.chr2 = self.getValue(key="CHR2", list=self.info)
        self.pos2 = self.getValue(key="END", list=self.info)
        self.connection = self.getValue(key="CT", list=self.info)
        self.PEsupport = self.getValue(key="PE", list=self.info)
        self.PEMapQual = self.getValue(key="MAPQ", list=self.info)
        self.SRsupport = self.getValue(key="SR", list=self.info)
        self.SRConsensusMapQual = self.getValue(key="SRQ", list=self.info)
        self.SRConsensusSeq = self.getValue(key="CONSENSUS", list=self.info)
        self.formatToks=toks[8].split(':')
        self.formatData=toks[9].split(':')
        self.varDepth = self.getValue(key="RC", list=self.formatData, listkeys=self.formatToks)
        self.refPairs = self.getValue(key="DR", list=self.formatData, listkeys=self.formatToks)
        self.varPairs = self.getValue(key="DV", list=self.formatData, listkeys=self.formatToks)
        self.refJxReads = self.getValue(key="RR", list=self.formatData, listkeys=self.formatToks)
        self.varJxReads = self.getValue(key="RV", list=self.formatData, listkeys=self.formatToks)

    def getValue(self, key, list, listkeys=None):
        '''
        Grabs the value from list for corresponding 'key', if it is uniquely found in listkeys (if None, then from list)
        :param list:
        :param listkeys:
        :param key:
        :return:
        '''
        if listkeys != None:
            keyList = listkeys
            valueList = list
            querykey = key
        else:
            keyList = list
            valueList = list
            querykey = key + "="
        hitIndices = [i for i, s in enumerate(keyList) if s.startswith(querykey)]
        if len(hitIndices) == 1:
            data=valueList[hitIndices[0]]
            if "=" in data:
                return data.split("=")[1]
            else:
                return data
        else:
            logging.warning("WARNING: Unique key '" + key + "' not found in VCF line.")
            return "-"

    def printVar(self):
        '''
        Prints variant to a string.
        :return:
        '''
        outString = self.chr1 + "\t" + self.pos1  + "\t" + self.chr2 + "\t" + self.pos2 + "\t" + self.filter + "\t" + \
                    self.varDepth + "\t" + self.PEsupport +  "\t" + self.PEMapQual +  "\t" + self.SRsupport + "\t" + \
                    self.SRConsensusMapQual + "\t" +self.SRConsensusSeq + "\t" + self.refPairs + "\t" + \
                    self.varPairs + "\t" + self.refJxReads + "\t" + self.varJxReads
        return outString

    def printTitle(self):
        title = "Chr1\tPos1\tChr2\tPos2\tCallQuality\tVariantDepth\tPairEndSupport\tPairEndMapQ\tSplitReadSupport\t" \
                "SplitReadConsensusMapQ\tSplitReadConsensusSeq\tReferencePairs\tVariantPairs\tRefJunctionReads\t" \
                "VarJunctionReads"
        return title

def parseDellyTx(folder):
    '''
    Parses a Delly VCF and writes out the calls as a table.
    :param folder:
    :return:
    '''
    folder = os.path.abspath(folder)
    logging.info("*Analyzing folder '" + folder +  "'.")
    allVCFs = glob.glob(folder + "/*.vcf")
    logging.info("Found " + str(len(allVCFs)) + " VCFs to parse in '" + folder + "'.")
    if len(allVCFs) == 0:
        logging.warning("WARNING: No Delly VCFs found.")
    #Find VCF in folder
    for file in allVCFs:
        logging.info("Parsing '" + file + "'.")
        outputTable =  file[:-4] + ".txt"
        logging.info("Output written to '" + outputTable + "'.")
        txList = []
        with open(file, 'r') as f:
            # Parse each tx call
            allLines=f.readlines()
            for line in allLines:
                if line[0] != "#":
                    dellyObj=DellyVCFline(line)
                    #print dellyObj.getValue(key="CHR2", list=dellyObj.info)
                    dellyObj.loadVar()
                    txList.append(dellyObj.printVar())

        # Add header & write to file
        txList = [dellyObj.printTitle()] + txList
        with open(outputTable, 'w') as outFH:
            outFH.write('\n'.join(txList))

if __name__ == "__main__":
    sys.exit(main())
