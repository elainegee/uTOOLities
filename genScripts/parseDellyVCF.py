#!/bin/python
import argparse
import sys
import glob
import logging
from datetime import datetime
import os

def main():
    # Setup logging
    LOG_FILENAME="logging-parseDellyVCF-" + datetime.now().strftime("%Y%m%d-%H%M%S") + ".log"
    logging.basicConfig(filename=LOG_FILENAME,
                        level = logging.DEBUG,
                        format = '%(asctime)s: %(message)s')
    logging.info("Starting parsing of Delly VCFs...")
    # Setup arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--folders', nargs='+', 
                        help='List of folders containing a VCF generated by Delly', 
                        required=True)
    parser.add_argument('-c', '--circos', action='store_true', 
                        help='Output bed-like file (includes _circ indicator in filename'
                             ' that can be read into makeCircos.r instead of the '
                             'standard full table output',
                        required=False)
    args = parser.parse_args()
    for folder in args.folders:
	if args.circos:
            parseDellyTx(folder, circos=True)
        else:	
            parseDellyTx(folder, circos=False)
    logging.info("DONE.")

class DellyVCFline(object):
    """
    Contains the lines of a Delly VCF.
    """
    def __init__(self, line):
        self.line = line
        self.info = None
        self.format = None
        self.chr1 = None
        self.chr2 = None
        self.pos1 = None
        self.pos2 = None
        self.precision = None
        self.filter = None
        self.connection = None
        self.PEsupport = None
        self.MQ = None  #for paired ends
        self.varDepth = None
        self.refPairs = None
        self.varPairs = None
        self.refJxReads = None
        self.varJxReads = None

    def loadVar(self):
        toks = self.line.strip('\n').split('\t')
        self.chr1 = toks[0]
        self.pos1 = toks[1]
        self.filter=toks[6]
        self.info=toks[7].split(';')
        self.precision=self.info[0]
        self.chr2 = self.getValue(key="CHR2", list=self.info)
        self.pos2 = self.getValue(key="END", list=self.info)
        self.connection = self.getValue(key="CT", list=self.info)
        self.PEsupport = self.getValue(key="PE", list=self.info)
        self.PEMapQual = self.getValue(key="MAPQ", list=self.info)
        self.SRsupport = self.getValue(key="SR", list=self.info)
        self.SRConsensusMapQual = self.getValue(key="SRQ", list=self.info)
        self.SRConsensusSeq = self.getValue(key="CONSENSUS", list=self.info)
        self.formatToks=toks[8].split(':')
        self.formatData=toks[9].split(':')
        self.varDepth = self.getValue(key="RC", list=self.formatData, listkeys=self.formatToks)
        self.refPairs = self.getValue(key="DR", list=self.formatData, listkeys=self.formatToks)
        self.varPairs = self.getValue(key="DV", list=self.formatData, listkeys=self.formatToks)
        self.refJxReads = self.getValue(key="RR", list=self.formatData, listkeys=self.formatToks)
        self.varJxReads = self.getValue(key="RV", list=self.formatData, listkeys=self.formatToks)

    def getValue(self, key, list, listkeys=None):
        '''
        Grabs the value from list for corresponding 'key', if it is uniquely found in listkeys (if None, then from list)
        :param list:
        :param listkeys:
        :param key:
        :return:
        '''
        if listkeys != None:
            keyList = listkeys
            valueList = list
            querykey = key
        else:
            keyList = list
            valueList = list
            querykey = key + "="
        hitIndices = [i for i, s in enumerate(keyList) if s.startswith(querykey)]
        if len(hitIndices) == 1:
            data=valueList[hitIndices[0]]
            if "=" in data:
                return data.split("=")[1]
            else:
                return data
        else:
            logging.warning("WARNING: Unique key '" + key + "' not found in VCF line.")
            return "-"

    def printVar(self):
        '''
        Prints variant to a list.
        :return:
        '''
        outString = [self.chr1, self.pos1, self.chr2, self.pos2, self.filter, \
                    self.varDepth, self.PEsupport, self.PEMapQual, self.SRsupport, \
                    self.SRConsensusMapQual, self.SRConsensusSeq, self.refPairs, \
                    self.varPairs, self.refJxReads, self.varJxReads]
        return outString

    def printTitle(self):
        title = ["Chr1", "Pos1", "Chr2", "Pos2", "CallQuality", \
                 "VariantDepth", "PairEndSupport", "PairEndMapQ", "SplitReadSupport", \
                 "SplitReadConsensusMapQ", "SplitReadConsensusSeq", "ReferencePairs", \
                 "VariantPairs", "RefJunctionReads", "VarJunctionReads"]
        return title

def set2Str(queryList):
    ''' Converts list with columns into a 1d array of string where columns are delimited
    by tabs. '''
    for index, value in enumerate(queryList):
        queryList[index] = '\t'.join(value) 

def parseDellyTx(folder, circos=False):
    '''
    Parses a Delly VCF and writes out the calls as a table. If circos=True, then it will
    output a file that is formated for compatibility with makeCircos.r
    :param folder:
    :return:
    '''
    folder = os.path.abspath(folder)
    logging.info("*Analyzing folder '" + folder +  "'.")
    allVCFs = glob.glob(folder + "/*.vcf")
    logging.info("Found " + str(len(allVCFs)) + " VCFs to parse in '" + folder + "'.")
    if len(allVCFs) == 0:
        logging.warning("WARNING: No Delly VCFs found.")
    #Find VCF in folder
    for file in allVCFs:
        logging.info("Parsing '" + file + "'.")
        if circos:
            circosStr="_circ"
        else:
            circosStr=""
	outputTable =  file[:-4] + circosStr + ".txt"
        logging.info("Output written to '" + outputTable + "'.")
        txList = []
        with open(file, 'r') as f:
            # Parse each tx call
            allLines=f.readlines()
            for line in allLines:
                if line[0] != "#":
                    dellyObj=DellyVCFline(line)
                    dellyObj.loadVar()
                    txList.append(dellyObj.printVar())
        outArr=txList
        with open(outputTable, 'w') as outFH:
	    if circos:
	        for index, entry in enumerate(outArr):
         	    tempList = [ entry[i] for i in [0,1,1,2,3,3,4] ]
                    tempList[0] = 'chr' + tempList[0]
                    tempList[2] = str(int(tempList[2]) + 10000000)
                    tempList[3] = 'chr' + tempList[3]
                    tempList[5] = str(int(tempList[5]) + 10000000)
                    if tempList[6] == "PASS":
                         tempList[6] = "1"
                    else:
                          tempList[6] = "0.05" 
                    outArr[index]=tempList 
            set2Str(outArr)
            outFH.write('\n'.join(outArr))

if __name__ == "__main__":
    sys.exit(main())
